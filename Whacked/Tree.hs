module Whacked.Tree where

-- | The Abstract Syntax Tree of the language. This tree is generated by the
-- parser and it includes information about the position of tokens inside the
-- source file in order for the type checker to be able to report  better error
-- messages.
-- The Abstract Syntax Tree is converted by the frontend generator into Itch,
-- the first intermediary language. Itch keeps the tree-like structure of
-- expressions, but unfolds loops and conditional statements into jumps and
-- target labels. When converting to Itch, position tags are stripped.

import Whacked.Types



data ATag
  = ATag
    { atSource :: String
    , atLine :: Int
    , atChar :: Int
    }
  deriving (Eq, Ord, Show)


data AProgram
  = AProgram
    { apFunctions :: [AFunction]
    }
  deriving (Eq, Ord, Show)


data AFunction
  = AFunction
    { afTag :: ATag
    , afArgs :: [AArg]
    , afType :: Type
    , afName :: String
    , afBody :: [AStatement]
    }
  deriving (Eq, Ord, Show)


data AArg
  = AArg
    { aaTag :: ATag
    , aaType :: Type
    , aaName :: String
    }
  deriving (Eq, Ord, Show)


data AStatement
  = AReturn
    { asTag   :: ATag
    , asExpr  :: AExpr
    }
  | APrint
    { asTag  :: ATag
    , asExpr :: AExpr
    }
  | APrintln
    { asTag :: ATag
    , asExpr :: AExpr
    }
  | AAssign
    { asTag  :: ATag
    , asTo   :: ALValue
    , asExpr :: AExpr
    }
  | ARead
    { asTag  :: ATag
    , asTo   :: ALValue
    }
  | AVarDecl
    { asTag  :: ATag
    , asType :: Type
    , asVars :: [(ATag, String, ARValue)]
    }
  | AWhile
    { asTag  :: ATag
    , asExpr :: AExpr
    , asBody :: [AStatement]
    }
  | AIf
    { asTag   :: ATag
    , asExpr  :: AExpr
    , asTrue  :: [AStatement]
    , asFalse :: [AStatement]
    }
  | ABlock
    { asTag  :: ATag
    , asBody :: [AStatement]
    }
  | ASkip
    { asTag :: ATag
    }
  | AExit
    { asTag  :: ATag
    , asExpr :: AExpr
    }
  | AFree
    { asTag :: ATag
    , asExpr :: AExpr
    }
  | AEnd
  deriving (Eq, Ord, Show)


data AExpr
  = AUnOp
    { aeTag  :: ATag
    , aeUnOp :: UnaryOp
    , aeArg  :: AExpr
    }
  | ABinOp
    { aeTag   :: ATag
    , aeBinOp :: BinaryOp
    , aeLeft  :: AExpr
    , aeRight :: AExpr
    }
  | AVar
    { aeTag  :: ATag
    , aeName :: String
    }
  | AConstInt
    { aeTag    :: ATag
    , aeIntVal :: Int
    }
  | AConstReal
    { aeTag     :: ATag
    , aeRealVal :: Float
    }
  | AConstChar
    { aeTag     :: ATag
    , aeCharVal :: Char
    }
  | AConstString
    { aeTag       :: ATag
    , aeStringVal :: String
    }
  | AConstBool
    { aeTag     :: ATag
    , aeBoolVal :: Bool
    }
  | ACall
    { aeTag  :: ATag
    , aeName :: String
    , aeArgs :: [AExpr]
    }
  | AIndex
    { aeTag   :: ATag
    , aeArray :: AExpr
    , aeIndex :: AExpr
    }
  | ANull
    { aeTag :: ATag
    }
  | ANewPair
    { aeTag :: ATag
    , aeFst :: AExpr
    , aeSnd :: AExpr
    }
  deriving (Eq, Ord, Show)


data ALValue
  = ALVar
    { alTag :: ATag
    , alName :: String
    }
  | ALFst
    { alTag :: ATag
    , alName :: String
    }
  | ALSnd
    { alTag :: ATag
    , alName :: String
    }
  | ALArray
    { alTag :: ATag
    , alName :: String
    , alIndex :: AExpr
    }
  deriving (Eq, Ord, Show)


data ARValue
  = ARExpr
    { arTag  :: ATag
    , arExpr :: AExpr
    }
  | ARArray
    { arTag   :: ATag
    , arElems :: [AExpr]
    }
  | ARTuple
    { arFst :: AExpr
    , arSnd :: AExpr
    }
  deriving (Eq, Ord, Show)
