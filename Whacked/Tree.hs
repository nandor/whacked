module Whacked.Tree where

-- | The Abstract Syntax Tree of the language. This tree is generated by the
-- parser and it includes information about the position of tokens inside the
-- source file in order for the type checker to be able to report  better error
-- messages.
-- The Abstract Syntax Tree is converted by the frontend generator into Itch,
-- the first intermediary language. Itch keeps the tree-like structure of
-- expressions, but unfolds loops and conditional statements into jumps and
-- target labels. When converting to Itch, position tags are stripped.

import Whacked.Types



data ATag
  = ATag
    { atSource :: String
    , atLine :: Int
    , atChar :: Int
    }
  deriving (Eq, Ord, Show)


data AProgram
  = AProgram
    { apFunctions :: [AFunction]
    }
  deriving (Eq, Ord, Show)


data AFunction
  = AFunction
    { afTag :: ATag
    , afArgs :: [AArg]
    , afType :: Type
    , afName :: String
    , afBody :: [AStatement]
    }
  deriving (Eq, Ord, Show)


data AArg
  = AArg
    { aaTag :: ATag
    , aaType :: Type
    , aaName :: String
    }
  deriving (Eq, Ord, Show)


data AStatement
  = AReturn
    { asTag   :: ATag
    , asExpr  :: AExpr
    }
  | APrint
    { asTag  :: ATag
    , asExpr :: AExpr
    }
  | AAssign
    { asTag  :: ATag
    , asTo   :: ALValue
    , asExpr :: AExpr
    }
  | AVarDecl
    { asTag  :: ATag
    , asType :: Type
    , asVars :: [(ATag, String, Maybe AExpr)]
    }
  | AWhile
    { asTag  :: ATag
    , asExpr :: AExpr
    , asBody :: [AStatement]
    }
  | AIf
    { asTag   :: ATag
    , asExpr  :: AExpr
    , asTrue  :: [AStatement]
    , asFalse :: [AStatement]
    }
  | ABlock
    { asTag  :: ATag
    , asBody :: [AStatement]
    }
  deriving (Eq, Ord, Show)


data AExpr
  = AUnOp
    { aeTag  :: ATag
    , aeUnOp :: UnaryOp
    , aeArg  :: AExpr
    }
  | ABinOp
    { aeTag   :: ATag
    , aeBinOp :: BinaryOp
    , aeLeft  :: AExpr
    , aeRight :: AExpr
    }
  | AVar
    { aeTag  :: ATag
    , aeName :: String
    }
  | AConstInt
    { aeTag    :: ATag
    , aeIntVal :: Int
    }
  | AConstReal
    { aeTag     :: ATag
    , aeRealVal :: Float
    }
  | AConstChar
    { aeTag     :: ATag
    , aeCharVal :: Char
    }
  | AConstString
    { aeTag :: ATag
    , aeStringVal :: String
    }
  | ACall
    { aeTag  :: ATag
    , aeName :: String
    , aeArgs :: [AExpr]
    }
  deriving (Eq, Ord, Show)


data ALValue
  = ALVar
    { alTag :: ATag
    , alName :: String
    }
  deriving (Eq, Ord, Show)
